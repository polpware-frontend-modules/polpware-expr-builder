{"version":3,"sources":["ng://@polpware/expr-builder/lib/binary-operators.ts"],"names":["OperatorEnum","OperatorOptions4Number","text","value","LessThan","LessThanEqual","Equal","NotEqual","GreaterThan","GreaterThanEqual","OperatorOptions4Bool","OperatorOptions4Text","Contain","NotContain","StartWith","EndWith","varName","varType","tyBool","tyNumber","tyDate","valueType","safeParseBool","safeParseFloat","safeParseString","op","ty","s","safeParseInt","tyString","Undefined"],"mappings":"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","sourcesContent":["import { ITypeDef, safeParseBool, safeParseFloat, safeParseInt, safeParseString, tyBool, tyDate, tyNumber, tyString } from '@polpware/fe-utilities';\n\nexport enum OperatorEnum {\n    Undefined = 0,\n    LessThan,\n    LessThanEqual,\n    Equal,\n    NotEqual,\n    GreaterThan,\n    GreaterThanEqual,\n\n    Contain,\n    NotContain,\n    StartWith,\n    EndWith\n}\n\nexport const OperatorOptions4Number = [\n    {\n        text: '<',\n        value: OperatorEnum.LessThan\n    }, {\n        text: '<=',\n        value: OperatorEnum.LessThanEqual\n    }, {\n        text: '==',\n        value: OperatorEnum.Equal\n    }, {\n        text: '!=',\n        value: OperatorEnum.NotEqual\n    }, {\n        text: '>',\n        value: OperatorEnum.GreaterThan\n    }, {\n        text: '>=',\n        value: OperatorEnum.GreaterThanEqual\n    }\n];\n\n\nexport const OperatorOptions4Bool = [\n    {\n        text: '==',\n        value: OperatorEnum.Equal\n    }, {\n        text: '!=',\n        value: OperatorEnum.NotEqual\n    }\n];\n\nexport const OperatorOptions4Text = [\n    {\n        text: 'Contains',\n        value: OperatorEnum.Contain\n    }, {\n        text: 'Contains no',\n        value: OperatorEnum.NotContain\n    }, {\n        text: 'Starts with',\n        value: OperatorEnum.StartWith\n    }, {\n        text: 'Ends with',\n        value: OperatorEnum.EndWith\n    }, {\n        text: '<',\n        value: OperatorEnum.LessThan\n    }, {\n        text: '<=',\n        value: OperatorEnum.LessThanEqual\n    }, {\n        text: '==',\n        value: OperatorEnum.Equal\n    }, {\n        text: '!=',\n        value: OperatorEnum.NotEqual\n    }, {\n        text: '>',\n        value: OperatorEnum.GreaterThan\n    }, {\n        text: '>=',\n        value: OperatorEnum.GreaterThanEqual\n    }\n];\n\nexport function interpretOperator(op: OperatorEnum, ty: ITypeDef) {\n    op = safeParseInt(op);\n    let s = '';\n    switch (op) {\n        case OperatorEnum.LessThan:\n            if (ty == tyString) {\n                s = 'String.Compare({left}, {right}, true) < 0';\n            } else {\n                s = '{left} < {right}';\n            }\n\n            break;\n        case OperatorEnum.LessThanEqual:\n            if (ty == tyString) {\n                s = 'String.Compare({left}, {right}, true) <= 0';\n            } else {\n                s = '{left} <= {right}';\n            }\n\n            break;\n        case OperatorEnum.Equal:\n            if (ty == tyString) {\n                s = 'String.Compare({left}, {right}, true) == 0';\n            } else {\n                s = '{left} == {right}';\n            }\n\n            break;\n        case OperatorEnum.NotEqual:\n            if (ty == tyString) {\n                s = 'String.Compare({left}, {right}, true) != 0';\n            } else {\n                s = '{left} != {right}';\n            }\n\n            break;\n        case OperatorEnum.GreaterThan:\n            if (ty == tyString) {\n                s = 'String.Compare({left}, {right}, true) > 0';\n            } else {\n                s = '{left} > {right}';\n            }\n\n            break;\n        case OperatorEnum.GreaterThanEqual:\n            if (ty == tyString) {\n                s = 'String.Compare({left}, {right}, true) >= 0';\n            } else {\n                s = '{left} >= {right}';\n            }\n\n            break;\n        case OperatorEnum.Contain:\n            s = '{left}.IndexOf({right}) != -1';\n            break;\n        case OperatorEnum.NotContain:\n            s = '{left}.IndexOf({right}) == -1';\n            break;\n        case OperatorEnum.StartWith:\n            s = '{left}.StartsWith({right})';\n            break;\n        case OperatorEnum.EndWith:\n            s = '{left}.EndsWith({right})';\n            break;\n        default:\n            s = '';\n            break;\n    }\n\n    return s;\n}\n\n/**\n * Translates the given string into a operator value.\n * Note that this method is expected to be invoked when  \n * parsing a dataflow or report. \n * Thus, the input value is well-defined and must be \n * one of the given value. \n * @param op\n */\nexport function translateStringToOperator(op: string) {\n    switch (op) {\n        case '<':\n            return OperatorEnum.LessThan;\n        case '<=':\n            return OperatorEnum.LessThanEqual;\n        case '==':\n            return OperatorEnum.Equal;\n        case '!=':\n            return OperatorEnum.NotEqual;\n        case '>':\n            return OperatorEnum.GreaterThan;\n        case '>=':\n            return OperatorEnum.GreaterThanEqual;\n        case 'Contains':\n            return OperatorEnum.Contain;\n        case 'DoesNotContain':\n            return OperatorEnum.NotContain;\n        case 'StartsWith':\n            return OperatorEnum.StartWith;\n        case 'EndsWith':\n            return OperatorEnum.EndWith;\n        default:\n            return OperatorEnum.Undefined;\n    }\n}\n\n/**\n * Computes the representation for the given value with the given type. \n * The given value is a known value, and it can be of one of many types. \n * Typically, the value is directly obtained from the user input in Form. \n *\n * Our goal is product a valid C# expression for the given value, while repsecting \n * the type information of the value. \n * \n * The representation is a valid C# expression. \n * @param value\n * @param valueType\n */\nexport function getTypeSafeValueRep(value: any, valueType: ITypeDef) {\n    if (valueType == tyBool) {\n        value = safeParseBool(value);\n    } else if (valueType == tyNumber) {\n        value = safeParseFloat(value);\n    } else if (valueType == tyDate) {\n        value = safeParseString(value);\n        value = '\"' + value + '\"';\n        value = `DateTime.Parse(${value})`;\n    } else { // string \n        value = safeParseString(value);\n        value = '\"' + value + '\"';\n    }\n    return value;\n}\n\n/**\n * Build the right type convertor (in C#) for the given variable (a string) \n * with the given type information. \n * \n * What is different from the above is that the above generates a valid literal from \n * a given known value. \n * \n * In contrast, the given value in this method is a variable (a string), we have to generate \n * a right type cast for the given string to produce a type safe value at run time. \n * Therefore, \n *   - we do not quote the given value. \n * @param varName\n * @param varType\n */\nexport function buildTypeConvertor(varName: string, varType: ITypeDef) {\n    if (varType == tyBool) {\n        varName = `bool.Parse(${varName})`;\n    } else if (varType == tyNumber) {\n        varName = `double.Parse(${varName})`;\n    } else if (varType == tyDate) {\n        varName = `DateTime.Parse(${varName})`;\n    }\n    return varName;\n}\n"]}