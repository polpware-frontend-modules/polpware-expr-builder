{"version":3,"file":"polpware-expr-builder.umd.js","sources":["ng://@polpware/expr-builder/lib/binary-operators.ts","ng://@polpware/expr-builder/lib/csharp-translator.ts","ng://@polpware/expr-builder/lib/js-evaluator.ts"],"sourcesContent":["export enum OperatorEnum {\n    Undefined = 0,\n    LessThan,\n    LessThanEqual,\n    Equal,\n    NotEqual,\n    GreaterThan,\n    GreaterThanEqual,\n\n    Contain,\n    NotContain,\n    StartWith,\n    EndWith\n}\n\nexport const OperatorOptions4Number = [\n    {\n        text: '<',\n        value: OperatorEnum.LessThan\n    }, {\n        text: '<=',\n        value: OperatorEnum.LessThanEqual\n    }, {\n        text: '==',\n        value: OperatorEnum.Equal\n    }, {\n        text: '!=',\n        value: OperatorEnum.NotEqual\n    }, {\n        text: '>',\n        value: OperatorEnum.GreaterThan\n    }, {\n        text: '>=',\n        value: OperatorEnum.GreaterThanEqual\n    }\n];\n\n\nexport const OperatorOptions4Bool = [\n    {\n        text: '==',\n        value: OperatorEnum.Equal\n    }, {\n        text: '!=',\n        value: OperatorEnum.NotEqual\n    }\n];\n\nexport const OperatorOptions4Text = [\n    {\n        text: 'Contains',\n        value: OperatorEnum.Contain\n    }, {\n        text: 'Contains no',\n        value: OperatorEnum.NotContain\n    }, {\n        text: 'Starts with',\n        value: OperatorEnum.StartWith\n    }, {\n        text: 'Ends with',\n        value: OperatorEnum.EndWith\n    }, {\n        text: '<',\n        value: OperatorEnum.LessThan\n    }, {\n        text: '<=',\n        value: OperatorEnum.LessThanEqual\n    }, {\n        text: '==',\n        value: OperatorEnum.Equal\n    }, {\n        text: '!=',\n        value: OperatorEnum.NotEqual\n    }, {\n        text: '>',\n        value: OperatorEnum.GreaterThan\n    }, {\n        text: '>=',\n        value: OperatorEnum.GreaterThanEqual\n    }\n];\n\n/**\n * Translates the given string into a operator value.\n * Note that this method is expected to be invoked when  \n * parsing a dataflow or report. \n * Thus, the input value is well-defined and must be \n * one of the given value. \n * @param op\n */\nexport function translateStringToOperator(op: string) {\n    switch (op) {\n        case '<':\n            return OperatorEnum.LessThan;\n        case '<=':\n            return OperatorEnum.LessThanEqual;\n        case '==':\n            return OperatorEnum.Equal;\n        case '!=':\n            return OperatorEnum.NotEqual;\n        case '>':\n            return OperatorEnum.GreaterThan;\n        case '>=':\n            return OperatorEnum.GreaterThanEqual;\n        case 'Contains':\n            return OperatorEnum.Contain;\n        case 'DoesNotContain':\n            return OperatorEnum.NotContain;\n        case 'StartsWith':\n            return OperatorEnum.StartWith;\n        case 'EndsWith':\n            return OperatorEnum.EndWith;\n        default:\n            return OperatorEnum.Undefined;\n    }\n}\n","import { ITypeDef, safeParseBool, safeParseFloat, safeParseInt, safeParseString, tyBool, tyDate, tyNumber, tyString } from '@polpware/fe-utilities';\nimport { OperatorEnum } from './binary-operators';\n\n/**\n * Translates into a string format for C#.\n * @param op\n * @param ty\n */\nexport function interpretOperator(op: OperatorEnum, ty: ITypeDef) {\n    op = safeParseInt(op);\n    let s = '';\n    switch (op) {\n        case OperatorEnum.LessThan:\n            if (ty == tyString) {\n                s = 'String.Compare({left}, {right}, true) < 0';\n            } else {\n                s = '{left} < {right}';\n            }\n\n            break;\n        case OperatorEnum.LessThanEqual:\n            if (ty == tyString) {\n                s = 'String.Compare({left}, {right}, true) <= 0';\n            } else {\n                s = '{left} <= {right}';\n            }\n\n            break;\n        case OperatorEnum.Equal:\n            if (ty == tyString) {\n                s = 'String.Compare({left}, {right}, true) == 0';\n            } else {\n                s = '{left} == {right}';\n            }\n\n            break;\n        case OperatorEnum.NotEqual:\n            if (ty == tyString) {\n                s = 'String.Compare({left}, {right}, true) != 0';\n            } else {\n                s = '{left} != {right}';\n            }\n\n            break;\n        case OperatorEnum.GreaterThan:\n            if (ty == tyString) {\n                s = 'String.Compare({left}, {right}, true) > 0';\n            } else {\n                s = '{left} > {right}';\n            }\n\n            break;\n        case OperatorEnum.GreaterThanEqual:\n            if (ty == tyString) {\n                s = 'String.Compare({left}, {right}, true) >= 0';\n            } else {\n                s = '{left} >= {right}';\n            }\n\n            break;\n        case OperatorEnum.Contain:\n            s = '{left}.IndexOf({right}) != -1';\n            break;\n        case OperatorEnum.NotContain:\n            s = '{left}.IndexOf({right}) == -1';\n            break;\n        case OperatorEnum.StartWith:\n            s = '{left}.StartsWith({right})';\n            break;\n        case OperatorEnum.EndWith:\n            s = '{left}.EndsWith({right})';\n            break;\n        default:\n            s = '';\n            break;\n    }\n\n    return s;\n}\n\n/**\n * Computes the representation for the given value with the given type. \n * The given value is a known value, and it can be of one of many types. \n * Typically, the value is directly obtained from the user input in Form. \n *\n * Our goal is product a valid C# expression for the given value, while repsecting \n * the type information of the value. \n * \n * The representation is a valid C# expression. \n * @param value\n * @param valueType\n */\nexport function getTypeSafeValueRep(value: any, valueType: ITypeDef) {\n    if (valueType == tyBool) {\n        value = safeParseBool(value);\n    } else if (valueType == tyNumber) {\n        value = safeParseFloat(value);\n    } else if (valueType == tyDate) {\n        value = safeParseString(value);\n        value = '\"' + value + '\"';\n        value = `DateTime.Parse(${value})`;\n    } else { // string \n        value = safeParseString(value);\n        value = '\"' + value + '\"';\n    }\n    return value;\n}\n\n/**\n * Build the right type convertor (in C#) for the given variable (a string) \n * with the given type information. \n * \n * What is different from the above is that the above generates a valid literal from \n * a given known value. \n * \n * In contrast, the given value in this method is a variable (a string), we have to generate \n * a right type cast for the given string to produce a type safe value at run time. \n * Therefore, \n *   - we do not quote the given value. \n * @param varName\n * @param varType\n */\nexport function buildTypeConvertor(varName: string, varType: ITypeDef) {\n    if (varType == tyBool) {\n        varName = `bool.Parse(${varName})`;\n    } else if (varType == tyNumber) {\n        varName = `double.Parse(${varName})`;\n    } else if (varType == tyDate) {\n        varName = `DateTime.Parse(${varName})`;\n    }\n    return varName;\n}\n","import { ITypeDef, safeParseBool, safeParseFloat, safeParseInt, safeParseString, tyBool, tyDate, tyNumber } from '@polpware/fe-utilities';\nimport { OperatorEnum } from './binary-operators';\n\n\n/**\n * Computes the type safe value in Javascript.\n * @param value\n * @param valueType\n */\nexport function getTypeSafeValue(value: any, valueType: ITypeDef) {\n    if (valueType == tyBool) {\n        value = safeParseBool(value);\n    } else if (valueType == tyNumber) {\n        value = safeParseFloat(value);\n    } else if (valueType == tyDate) {\n        value = safeParseString(value);\n        value = Date.parse(value);\n    } else { // string \n        value = safeParseString(value);\n    }\n    return value;\n}\n\n\n/**\n * Evalutes the given assertion if it holds.\n * @param value\n * @param op\n * @param ty\n * @param expected\n */\nexport function evaluateAssertion(value: any, op: OperatorEnum, ty: ITypeDef, expected: any): boolean {\n    op = safeParseInt(op);\n    let s = false;\n    switch (op) {\n        case OperatorEnum.LessThan:\n            s = getTypeSafeValue(value, ty) < getTypeSafeValue(expected, ty);\n            break;\n        case OperatorEnum.LessThanEqual:\n            s = getTypeSafeValue(value, ty) <= getTypeSafeValue(expected, ty);\n            break;\n        case OperatorEnum.Equal:\n            s = getTypeSafeValue(value, ty) == getTypeSafeValue(expected, ty);\n            break;\n        case OperatorEnum.NotEqual:\n            s = getTypeSafeValue(value, ty) != getTypeSafeValue(expected, ty);\n            break;\n        case OperatorEnum.GreaterThan:\n            s = getTypeSafeValue(value, ty) > getTypeSafeValue(expected, ty);\n            break;\n        case OperatorEnum.GreaterThanEqual:\n            s = getTypeSafeValue(value, ty) >= getTypeSafeValue(expected, ty);\n            break;\n        case OperatorEnum.Contain:\n            s = (getTypeSafeValue(value, ty) as string).indexOf(getTypeSafeValue(expected, ty)) != -1;\n            break;\n        case OperatorEnum.NotContain:\n            s = getTypeSafeValue(value, ty).indexOf(getTypeSafeValue(expected, ty)) == -1;\n            break;\n        case OperatorEnum.StartWith:\n            s = (getTypeSafeValue(value, ty) as string).startsWith(getTypeSafeValue(expected, ty));\n            break;\n        case OperatorEnum.EndWith:\n            s = (getTypeSafeValue(value, ty) as string).endsWith(getTypeSafeValue(expected, ty));\n            break;\n        default:\n            break;\n    }\n\n    return s;\n}\n"],"names":["OperatorEnum","safeParseInt","tyString","tyBool","safeParseBool","tyNumber","safeParseFloat","tyDate","safeParseString"],"mappings":"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"}