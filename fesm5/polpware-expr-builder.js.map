{"version":3,"file":"polpware-expr-builder.js","sources":["ng://@polpware/expr-builder/lib/binary-operators.ts","ng://@polpware/expr-builder/lib/csharp-translator.ts","ng://@polpware/expr-builder/lib/js-evaluator.ts","ng://@polpware/expr-builder/public-api.ts","ng://@polpware/expr-builder/polpware-expr-builder.ts"],"sourcesContent":["export enum OperatorEnum {\n    Undefined = 0,\n    LessThan,\n    LessThanEqual,\n    Equal,\n    NotEqual,\n    GreaterThan,\n    GreaterThanEqual,\n\n    Contain,\n    NotContain,\n    StartWith,\n    EndWith\n}\n\nexport const OperatorOptions4Number = [\n    {\n        text: '<',\n        value: OperatorEnum.LessThan\n    }, {\n        text: '<=',\n        value: OperatorEnum.LessThanEqual\n    }, {\n        text: '==',\n        value: OperatorEnum.Equal\n    }, {\n        text: '!=',\n        value: OperatorEnum.NotEqual\n    }, {\n        text: '>',\n        value: OperatorEnum.GreaterThan\n    }, {\n        text: '>=',\n        value: OperatorEnum.GreaterThanEqual\n    }\n];\n\n\nexport const OperatorOptions4Bool = [\n    {\n        text: '==',\n        value: OperatorEnum.Equal\n    }, {\n        text: '!=',\n        value: OperatorEnum.NotEqual\n    }\n];\n\nexport const OperatorOptions4Text = [\n    {\n        text: 'Contains',\n        value: OperatorEnum.Contain\n    }, {\n        text: 'Contains no',\n        value: OperatorEnum.NotContain\n    }, {\n        text: 'Starts with',\n        value: OperatorEnum.StartWith\n    }, {\n        text: 'Ends with',\n        value: OperatorEnum.EndWith\n    }, {\n        text: '<',\n        value: OperatorEnum.LessThan\n    }, {\n        text: '<=',\n        value: OperatorEnum.LessThanEqual\n    }, {\n        text: '==',\n        value: OperatorEnum.Equal\n    }, {\n        text: '!=',\n        value: OperatorEnum.NotEqual\n    }, {\n        text: '>',\n        value: OperatorEnum.GreaterThan\n    }, {\n        text: '>=',\n        value: OperatorEnum.GreaterThanEqual\n    }\n];\n\n/**\n * Translates the given string into a operator value.\n * Note that this method is expected to be invoked when  \n * parsing a dataflow or report. \n * Thus, the input value is well-defined and must be \n * one of the given value. \n * @param op\n */\nexport function translateStringToOperator(op: string) {\n    switch (op) {\n        case '<':\n            return OperatorEnum.LessThan;\n        case '<=':\n            return OperatorEnum.LessThanEqual;\n        case '==':\n            return OperatorEnum.Equal;\n        case '!=':\n            return OperatorEnum.NotEqual;\n        case '>':\n            return OperatorEnum.GreaterThan;\n        case '>=':\n            return OperatorEnum.GreaterThanEqual;\n        case 'Contains':\n            return OperatorEnum.Contain;\n        case 'DoesNotContain':\n            return OperatorEnum.NotContain;\n        case 'StartsWith':\n            return OperatorEnum.StartWith;\n        case 'EndsWith':\n            return OperatorEnum.EndWith;\n        default:\n            return OperatorEnum.Undefined;\n    }\n}\n","import { ITypeDef, safeParseBool, safeParseFloat, safeParseInt, safeParseString, tyBool, tyDate, tyNumber, tyString } from '@polpware/fe-utilities';\nimport { OperatorEnum } from './binary-operators';\n\n/**\n * Translates into a string format for C#.\n * @param op\n * @param ty\n */\nexport function interpretOperator(op: OperatorEnum, ty: ITypeDef) {\n    op = safeParseInt(op);\n    let s = '';\n    switch (op) {\n        case OperatorEnum.LessThan:\n            if (ty == tyString) {\n                s = 'String.Compare({left}, {right}, true) < 0';\n            } else {\n                s = '{left} < {right}';\n            }\n\n            break;\n        case OperatorEnum.LessThanEqual:\n            if (ty == tyString) {\n                s = 'String.Compare({left}, {right}, true) <= 0';\n            } else {\n                s = '{left} <= {right}';\n            }\n\n            break;\n        case OperatorEnum.Equal:\n            if (ty == tyString) {\n                s = 'String.Compare({left}, {right}, true) == 0';\n            } else {\n                s = '{left} == {right}';\n            }\n\n            break;\n        case OperatorEnum.NotEqual:\n            if (ty == tyString) {\n                s = 'String.Compare({left}, {right}, true) != 0';\n            } else {\n                s = '{left} != {right}';\n            }\n\n            break;\n        case OperatorEnum.GreaterThan:\n            if (ty == tyString) {\n                s = 'String.Compare({left}, {right}, true) > 0';\n            } else {\n                s = '{left} > {right}';\n            }\n\n            break;\n        case OperatorEnum.GreaterThanEqual:\n            if (ty == tyString) {\n                s = 'String.Compare({left}, {right}, true) >= 0';\n            } else {\n                s = '{left} >= {right}';\n            }\n\n            break;\n        case OperatorEnum.Contain:\n            s = '{left}.IndexOf({right}) != -1';\n            break;\n        case OperatorEnum.NotContain:\n            s = '{left}.IndexOf({right}) == -1';\n            break;\n        case OperatorEnum.StartWith:\n            s = '{left}.StartsWith({right})';\n            break;\n        case OperatorEnum.EndWith:\n            s = '{left}.EndsWith({right})';\n            break;\n        default:\n            s = '';\n            break;\n    }\n\n    return s;\n}\n\n/**\n * Computes the representation for the given value with the given type. \n * The given value is a known value, and it can be of one of many types. \n * Typically, the value is directly obtained from the user input in Form. \n *\n * Our goal is product a valid C# expression for the given value, while repsecting \n * the type information of the value. \n * \n * The representation is a valid C# expression. \n * @param value\n * @param valueType\n */\nexport function getTypeSafeValueRep(value: any, valueType: ITypeDef) {\n    if (valueType == tyBool) {\n        value = safeParseBool(value);\n    } else if (valueType == tyNumber) {\n        value = safeParseFloat(value);\n    } else if (valueType == tyDate) {\n        value = safeParseString(value);\n        value = '\"' + value + '\"';\n        value = `DateTime.Parse(${value})`;\n    } else { // string \n        value = safeParseString(value);\n        value = '\"' + value + '\"';\n    }\n    return value;\n}\n\n/**\n * Build the right type convertor (in C#) for the given variable (a string) \n * with the given type information. \n * \n * What is different from the above is that the above generates a valid literal from \n * a given known value. \n * \n * In contrast, the given value in this method is a variable (a string), we have to generate \n * a right type cast for the given string to produce a type safe value at run time. \n * Therefore, \n *   - we do not quote the given value. \n * @param varName\n * @param varType\n */\nexport function buildTypeConvertor(varName: string, varType: ITypeDef) {\n    if (varType == tyBool) {\n        varName = `bool.Parse(${varName})`;\n    } else if (varType == tyNumber) {\n        varName = `double.Parse(${varName})`;\n    } else if (varType == tyDate) {\n        varName = `DateTime.Parse(${varName})`;\n    }\n    return varName;\n}\n","import { ITypeDef, safeParseBool, safeParseFloat, safeParseInt, safeParseString, tyBool, tyDate, tyNumber } from '@polpware/fe-utilities';\nimport { OperatorEnum } from './binary-operators';\n\n\n/**\n * Computes the type safe value in Javascript.\n * @param value\n * @param valueType\n */\nexport function getTypeSafeValue(value: any, valueType: ITypeDef) {\n    if (valueType == tyBool) {\n        value = safeParseBool(value);\n    } else if (valueType == tyNumber) {\n        value = safeParseFloat(value);\n    } else if (valueType == tyDate) {\n        value = safeParseString(value);\n        value = Date.parse(value);\n    } else { // string \n        value = safeParseString(value);\n    }\n    return value;\n}\n\n\n/**\n * Evalutes the given assertion if it holds.\n * @param value\n * @param op\n * @param ty\n * @param expected\n */\nexport function evaluateAssertion(value: any, op: OperatorEnum, ty: ITypeDef, expected: any): boolean {\n    op = safeParseInt(op);\n    let s = false;\n    switch (op) {\n        case OperatorEnum.LessThan:\n            s = getTypeSafeValue(value, ty) < getTypeSafeValue(expected, ty);\n            break;\n        case OperatorEnum.LessThanEqual:\n            s = getTypeSafeValue(value, ty) <= getTypeSafeValue(expected, ty);\n            break;\n        case OperatorEnum.Equal:\n            s = getTypeSafeValue(value, ty) == getTypeSafeValue(expected, ty);\n            break;\n        case OperatorEnum.NotEqual:\n            s = getTypeSafeValue(value, ty) != getTypeSafeValue(expected, ty);\n            break;\n        case OperatorEnum.GreaterThan:\n            s = getTypeSafeValue(value, ty) > getTypeSafeValue(expected, ty);\n            break;\n        case OperatorEnum.GreaterThanEqual:\n            s = getTypeSafeValue(value, ty) >= getTypeSafeValue(expected, ty);\n            break;\n        case OperatorEnum.Contain:\n            s = (getTypeSafeValue(value, ty) as string).indexOf(getTypeSafeValue(expected, ty)) != -1;\n            break;\n        case OperatorEnum.NotContain:\n            s = getTypeSafeValue(value, ty).indexOf(getTypeSafeValue(expected, ty)) == -1;\n            break;\n        case OperatorEnum.StartWith:\n            s = (getTypeSafeValue(value, ty) as string).startsWith(getTypeSafeValue(expected, ty));\n            break;\n        case OperatorEnum.EndWith:\n            s = (getTypeSafeValue(value, ty) as string).endsWith(getTypeSafeValue(expected, ty));\n            break;\n        default:\n            break;\n    }\n\n    return s;\n}\n","/*\n * Public API Surface of expr-builder\n */\n\nexport * from './lib/binary-operators';\nexport * from './lib/csharp-translator';\nexport * from './lib/js-evaluator';\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n"],"names":[],"mappings":"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"}