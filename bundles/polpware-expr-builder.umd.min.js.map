{"version":3,"sources":["ng://@polpware/expr-builder/lib/binary-operators.ts","ng://@polpware/expr-builder/lib/js-evaluator.ts","ng://@polpware/expr-builder/lib/csharp-translator.ts"],"names":["OperatorEnum","OperatorOptions4Number","text","value","LessThan","LessThanEqual","Equal","NotEqual","GreaterThan","GreaterThanEqual","OperatorOptions4Bool","OperatorOptions4Text","Contain","NotContain","StartWith","EndWith","getTypeSafeValue","valueType","tyBool","safeParseBool","tyNumber","safeParseFloat","tyDate","safeParseString","Date","parse","varName","varType","op","ty","expected","s","safeParseInt","indexOf","startsWith","endsWith","tyString","Undefined","tyNull","tyUndefined","tySymbol","tyObject","tyArray","tyFunction"],"mappings":"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","sourcesContent":["import { tyBool, tyNull, tyUndefined, tyNumber, tyString, tyDate, tySymbol, tyObject, tyArray, tyFunction } from '@polpware/fe-utilities';\n\nexport enum OperatorEnum {\n    Undefined = 0,\n    LessThan,\n    LessThanEqual,\n    Equal,\n    NotEqual,\n    GreaterThan,\n    GreaterThanEqual,\n\n    Contain,\n    NotContain,\n    StartWith,\n    EndWith\n}\n\nexport const OperatorOptions4Number = [\n    {\n        text: '<',\n        value: OperatorEnum.LessThan\n    }, {\n        text: '<=',\n        value: OperatorEnum.LessThanEqual\n    }, {\n        text: '==',\n        value: OperatorEnum.Equal\n    }, {\n        text: '!=',\n        value: OperatorEnum.NotEqual\n    }, {\n        text: '>',\n        value: OperatorEnum.GreaterThan\n    }, {\n        text: '>=',\n        value: OperatorEnum.GreaterThanEqual\n    }\n];\n\n\nexport const OperatorOptions4Bool = [\n    {\n        text: '==',\n        value: OperatorEnum.Equal\n    }, {\n        text: '!=',\n        value: OperatorEnum.NotEqual\n    }\n];\n\nexport const OperatorOptions4Text = [\n    {\n        text: 'Contains',\n        value: OperatorEnum.Contain\n    }, {\n        text: 'Contains no',\n        value: OperatorEnum.NotContain\n    }, {\n        text: 'Starts with',\n        value: OperatorEnum.StartWith\n    }, {\n        text: 'Ends with',\n        value: OperatorEnum.EndWith\n    }, {\n        text: '<',\n        value: OperatorEnum.LessThan\n    }, {\n        text: '<=',\n        value: OperatorEnum.LessThanEqual\n    }, {\n        text: '==',\n        value: OperatorEnum.Equal\n    }, {\n        text: '!=',\n        value: OperatorEnum.NotEqual\n    }, {\n        text: '>',\n        value: OperatorEnum.GreaterThan\n    }, {\n        text: '>=',\n        value: OperatorEnum.GreaterThanEqual\n    }\n];\n\n/**\n * Translates the given string into a operator value.\n * Note that this method is expected to be invoked when  \n * parsing a dataflow or report. \n * Thus, the input value is well-defined and must be \n * one of the given value. \n * @param op\n */\nexport function translateStringToOperator(op: string) {\n    switch (op) {\n        case '<':\n            return OperatorEnum.LessThan;\n        case '<=':\n            return OperatorEnum.LessThanEqual;\n        case '==':\n            return OperatorEnum.Equal;\n        case '!=':\n            return OperatorEnum.NotEqual;\n        case '>':\n            return OperatorEnum.GreaterThan;\n        case '>=':\n            return OperatorEnum.GreaterThanEqual;\n        case 'Contains':\n            return OperatorEnum.Contain;\n        case 'DoesNotContain':\n            return OperatorEnum.NotContain;\n        case 'StartsWith':\n            return OperatorEnum.StartWith;\n        case 'EndsWith':\n            return OperatorEnum.EndWith;\n        default:\n            return OperatorEnum.Undefined;\n    }\n}\n\n/**\n * Translates the given into a JavaSrcipt type.\n * @param ty\n */\nexport function translateStringToType(ty: string) {\n    switch (ty) {\n        case 'tyBool':\n            return tyBool;\n        case 'tyNull':\n            return tyNull;\n        case 'tyUndefined':\n            return tyUndefined;\n        case 'tyNumber':\n            return tyNumber;\n        case 'tyString':\n            return tyString;\n        case 'tyDate':\n            return tyDate;\n        case 'tySymbol':\n            return tySymbol;\n        case 'tyObject':\n            return tyObject;\n        case 'tyArray':\n            return tyArray;\n        case 'tyFunction':\n            return tyFunction;\n        default:\n            return tyString;\n    }\n}\n","import { ITypeDef, safeParseBool, safeParseFloat, safeParseInt, safeParseString, tyBool, tyDate, tyNumber } from '@polpware/fe-utilities';\nimport { OperatorEnum } from './binary-operators';\n\n\n/**\n * Computes the type safe value in Javascript.\n * @param value\n * @param valueType\n */\nexport function getTypeSafeValue(value: any, valueType: ITypeDef) {\n    if (valueType == tyBool) {\n        value = safeParseBool(value);\n    } else if (valueType == tyNumber) {\n        value = safeParseFloat(value);\n    } else if (valueType == tyDate) {\n        value = safeParseString(value);\n        value = Date.parse(value);\n    } else { // string \n        value = safeParseString(value);\n    }\n    return value;\n}\n\n\n/**\n * Evalutes the given assertion if it holds.\n * @param value\n * @param op\n * @param ty\n * @param expected\n */\nexport function evaluateAssertion(value: any, op: OperatorEnum, ty: ITypeDef, expected: any): boolean {\n    op = safeParseInt(op);\n    let s = false;\n    switch (op) {\n        case OperatorEnum.LessThan:\n            s = getTypeSafeValue(value, ty) < getTypeSafeValue(expected, ty);\n            break;\n        case OperatorEnum.LessThanEqual:\n            s = getTypeSafeValue(value, ty) <= getTypeSafeValue(expected, ty);\n            break;\n        case OperatorEnum.Equal:\n            s = getTypeSafeValue(value, ty) == getTypeSafeValue(expected, ty);\n            break;\n        case OperatorEnum.NotEqual:\n            s = getTypeSafeValue(value, ty) != getTypeSafeValue(expected, ty);\n            break;\n        case OperatorEnum.GreaterThan:\n            s = getTypeSafeValue(value, ty) > getTypeSafeValue(expected, ty);\n            break;\n        case OperatorEnum.GreaterThanEqual:\n            s = getTypeSafeValue(value, ty) >= getTypeSafeValue(expected, ty);\n            break;\n        case OperatorEnum.Contain:\n            s = (getTypeSafeValue(value, ty) as string).indexOf(getTypeSafeValue(expected, ty)) != -1;\n            break;\n        case OperatorEnum.NotContain:\n            s = getTypeSafeValue(value, ty).indexOf(getTypeSafeValue(expected, ty)) == -1;\n            break;\n        case OperatorEnum.StartWith:\n            s = (getTypeSafeValue(value, ty) as string).startsWith(getTypeSafeValue(expected, ty));\n            break;\n        case OperatorEnum.EndWith:\n            s = (getTypeSafeValue(value, ty) as string).endsWith(getTypeSafeValue(expected, ty));\n            break;\n        default:\n            break;\n    }\n\n    return s;\n}\n","import { ITypeDef, safeParseBool, safeParseFloat, safeParseInt, safeParseString, tyBool, tyDate, tyNumber, tyString } from '@polpware/fe-utilities';\nimport { OperatorEnum } from './binary-operators';\n\n/**\n * Translates into a string format for C#.\n * @param op\n * @param ty\n */\nexport function interpretOperator(op: OperatorEnum, ty: ITypeDef) {\n    op = safeParseInt(op);\n    let s = '';\n    switch (op) {\n        case OperatorEnum.LessThan:\n            if (ty == tyString) {\n                s = 'String.Compare({left}, {right}, true) < 0';\n            } else {\n                s = '{left} < {right}';\n            }\n\n            break;\n        case OperatorEnum.LessThanEqual:\n            if (ty == tyString) {\n                s = 'String.Compare({left}, {right}, true) <= 0';\n            } else {\n                s = '{left} <= {right}';\n            }\n\n            break;\n        case OperatorEnum.Equal:\n            if (ty == tyString) {\n                s = 'String.Compare({left}, {right}, true) == 0';\n            } else {\n                s = '{left} == {right}';\n            }\n\n            break;\n        case OperatorEnum.NotEqual:\n            if (ty == tyString) {\n                s = 'String.Compare({left}, {right}, true) != 0';\n            } else {\n                s = '{left} != {right}';\n            }\n\n            break;\n        case OperatorEnum.GreaterThan:\n            if (ty == tyString) {\n                s = 'String.Compare({left}, {right}, true) > 0';\n            } else {\n                s = '{left} > {right}';\n            }\n\n            break;\n        case OperatorEnum.GreaterThanEqual:\n            if (ty == tyString) {\n                s = 'String.Compare({left}, {right}, true) >= 0';\n            } else {\n                s = '{left} >= {right}';\n            }\n\n            break;\n        case OperatorEnum.Contain:\n            s = '{left}.IndexOf({right}) != -1';\n            break;\n        case OperatorEnum.NotContain:\n            s = '{left}.IndexOf({right}) == -1';\n            break;\n        case OperatorEnum.StartWith:\n            s = '{left}.StartsWith({right})';\n            break;\n        case OperatorEnum.EndWith:\n            s = '{left}.EndsWith({right})';\n            break;\n        default:\n            s = '';\n            break;\n    }\n\n    return s;\n}\n\n/**\n * Computes the representation for the given value with the given type. \n * The given value is a known value, and it can be of one of many types. \n * Typically, the value is directly obtained from the user input in Form. \n *\n * Our goal is product a valid C# expression for the given value, while repsecting \n * the type information of the value. \n * \n * The representation is a valid C# expression. \n * @param value\n * @param valueType\n */\nexport function getTypeSafeValueRep(value: any, valueType: ITypeDef) {\n    if (valueType == tyBool) {\n        value = safeParseBool(value);\n    } else if (valueType == tyNumber) {\n        value = safeParseFloat(value);\n    } else if (valueType == tyDate) {\n        value = safeParseString(value);\n        value = '\"' + value + '\"';\n        value = `DateTime.Parse(${value})`;\n    } else { // string \n        value = safeParseString(value);\n        value = '\"' + value + '\"';\n    }\n    return value;\n}\n\n/**\n * Build the right type convertor (in C#) for the given variable (a string) \n * with the given type information. \n * \n * What is different from the above is that the above generates a valid literal from \n * a given known value. \n * \n * In contrast, the given value in this method is a variable (a string), we have to generate \n * a right type cast for the given string to produce a type safe value at run time. \n * Therefore, \n *   - we do not quote the given value. \n * @param varName\n * @param varType\n */\nexport function buildTypeConvertor(varName: string, varType: ITypeDef) {\n    if (varType == tyBool) {\n        varName = `bool.Parse(${varName})`;\n    } else if (varType == tyNumber) {\n        varName = `double.Parse(${varName})`;\n    } else if (varType == tyDate) {\n        varName = `DateTime.Parse(${varName})`;\n    }\n    return varName;\n}\n"]}